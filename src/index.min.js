/*!
 * options-config v1.2.0
 * by Nil Vila
 */
import getType from"./helpers/getType";import inRange from"./helpers/inRange";import isValid from"./helpers/isValid";function validateValue(e,t,a){const r=a[e],o=t[e],l=r.type,n=r.valid,i=r.range,s=r.match,c=r.default,p=`'${e}' now has its default value ('${c}').`;if(!o&&!1!==o&&0!==o)return c;if(s)return"string"===getType(o)&&o.match(s)&&o.match(s)[0]===o?o:(console.error(`'${o}' doesn't match the RegExp expression for '${e}'.`),console.warn(p),c);if(n)return isValid(o,n,l)?o:(console.error(`'${o}' is not a valid value for '${e}'.`),console.warn(p),c);if(l&&!l.includes(getType(o))){const t="array"===getType(l)?`${l.slice(0,-1).join(", ")} or ${l.slice(-1)}`:l;return console.error(`Data type for '${e}' should be ${t}, but not ${getType(o)}.`),console.warn(p),c}return i&&!inRange(o,i.min,i.max,i.step)?(console.error(`${o} is not a valid number for '${e}'.`),console.warn(p),c):o}export default class{constructor(e){this.defaults=e}validate(e,t=this.defaults){const a={};for(const r in t)if(Object.prototype.hasOwnProperty.call(t,r)){let o,l,n,i,s=t[r];if(!s.default&&!1!==s.default&&0!==s.default||"object"===getType(s.default)){a[r]={},s.default&&(o=s.type,l=s.valid,n=s.range,i=s.match,s=s.default);for(const t in s)Object.prototype.hasOwnProperty.call(s,t)&&(s[t].type=s[t].type||o,s[t].valid=s[t].valid||l,s[t].range=s[t].range||n,s[t].match=s[t].match||i,a[r][t]=validateValue(t,e[r],s))}else a[r]=validateValue(r,e,t)}return a}}