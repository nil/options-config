/*!
 * options-config v1.1.2
 * by Nil Vila
 */
import getType from"./helpers/getType";import inRange from"./helpers/inRange";import isValid from"./helpers/isValid";function validateValue(e,t,a){const l=a[e],r=t[e],o=l.type,i=l.valid,n=l.range,s=l.default,u=`'${e}' now has its default value ('${s}').`;if(!r&&!1!==r&&0!==r)return s;if(i)return isValid(r,i,o)?r:(console.error(`'${r}' is not a valid value for '${e}'.`),console.warn(u),s);if(o&&!o.includes(getType(r))){const t="array"===getType(o)?`${o.slice(0,-1).join(", ")} or ${o.slice(-1)}`:o;return console.error(`Data type for '${e}' should be ${t}, but not ${getType(r)}.`),console.warn(u),s}return n&&!inRange(r,n.min,n.max,n.step)?s:r}export default class{constructor(e){this.defaults=e}validate(e,t=this.defaults){const a={};for(const l in t)if(Object.prototype.hasOwnProperty.call(t,l)){let r,o,i=t[l];if(!i.default&&!1!==i.default&&0!==i.default||"object"===getType(i.default)){a[l]={},i.default&&(r=i.type,o=i.valid,i=i.default);for(const t in i)Object.prototype.hasOwnProperty.call(i,t)&&(i[t].type=i[t].type||r,i[t].valid=i[t].valid||o,a[l][t]=validateValue(t,e[l],i))}else a[l]=validateValue(l,e,t)}return a}}