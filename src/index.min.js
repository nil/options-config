/*!
 * options-config v1.0.1
 * by Nil Vila
 */
export function getType(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}export function areArraysEqual(e,t){if(e.length!==t.length)return!1;for(const r of e)if(e[r]!==t[r])return!1;return!0}export function checkIfValueAccepted(e,t){if("array"===getType(e)){for(let r=0;r<t.length;++r)if(areArraysEqual(t[r],e))return!0;return!1}return t.includes(e)}export function validateChosenValue(e,t,r){const a=r[e],l=t[e],o=a.type,n=a.values,u=a.default;return l||!1===l||0===l?o&&!o.includes(getType(l))?(console.error("type not correct"),u):n&&!checkIfValueAccepted(l,n)?(console.error("value not accepted"),u):l:u}export default class{constructor(e){this.defaults=e}validate(e,t=this.defaults){const r={};for(const a in t)if(Object.prototype.hasOwnProperty.call(t,a)){let l,o,n=t[a];if(!n.default&&!1!==n.default&&0!==n.default||"object"===getType(n.default)){r[a]={},n.default&&(l=n.type,o=n.values,n=n.default);for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&(n[t].type=n[t].type||l,n[t].values=n[t].values||o,r[a][t]=validateChosenValue(t,e[a],n))}else r[a]=validateChosenValue(a,e,t)}return r}}