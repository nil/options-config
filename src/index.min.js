/*!
 * options-config v1.0.2
 * by Nil Vila
 */
export function getType(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}export function areArraysEqual(e,t){if(e.length!==t.length)return!1;for(const r of e)if(e[r]!==t[r])return!1;return!0}export function checkIfValueAccepted(e,t){if("array"===getType(e)){for(let r=0;r<t.length;++r)if(areArraysEqual(t[r],e))return!0;return!1}return t.includes(e)}export function validateChosenValue(e,t,r){const a=r[e],o=t[e],l=a.type,n=a.values,u=a.default,s=`'${e}' now has its default value ('${u}').`;if(!o&&!1!==o&&0!==o)return u;if(l&&!l.includes(getType(o))){const t="array"===getType(l)?`${l.slice(0,-1).join(", ")} or ${l.slice(-1)}`:l;return console.error(`Data type for '${e}' should be ${t}, but not ${getType(o)}.`),console.warn(s),u}return n&&!checkIfValueAccepted(o,n)?(console.error(`'${o}' is not an accepted value for '${e}'.`),console.warn(s),u):o}export default class{constructor(e){this.defaults=e}validate(e,t=this.defaults){const r={};for(const a in t)if(Object.prototype.hasOwnProperty.call(t,a)){let o,l,n=t[a];if(!n.default&&!1!==n.default&&0!==n.default||"object"===getType(n.default)){r[a]={},n.default&&(o=n.type,l=n.values,n=n.default);for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&(n[t].type=n[t].type||o,n[t].values=n[t].values||l,r[a][t]=validateChosenValue(t,e[a],n))}else r[a]=validateChosenValue(a,e,t)}return r}}