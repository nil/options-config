/*!
 * options-config v3.1.2
 * by Nil Vila
 */
"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}var isNumber=_interopDefault(require("lodash.isnumber")),customError=_interopDefault(require("custom-error")),isEqual=_interopDefault(require("lodash.isequal")),includes=_interopDefault(require("lodash.includes"));function getType(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function hasKey(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function printError(e){throw customError("options-config")(e)}function inRange(e,t,r){if(r){const i=r.min,n=r.max,a=r.step;(!isNumber(i)&&void 0!==i||!isNumber(n)&&void 0!==n||!isNumber(a)&&void 0!==a)&&printError(`Range is not properly configured for '${e}'.`),(i>t||n<t||a&&!Number.isInteger(((i||0)-t)/a))&&printError(`${t} doesn't fit the range specified for '${e}'.`)}return!1}function isDeclared(e){return"value_not_defined"===e}function isMatch(e,t,r){if(r){if("string"===getType(t)&&t.match(r)&&t.match(r)[0]===t)return!0;printError(`'${t}' doesn't match the Regex expression ${r} for '${e}'.`)}return!1}function isType(e,t,r){const i=getType(t);if(r&&!r.includes(i)){printError(`'${t}', ${i}, is not a valid data type for '${e}' (${"array"===getType(r)&&r.length>1?`${r.slice(0,-1).join(", ")} or ${r.slice(-1)}`:`${r}`}).`)}return!1}function isValid(e,t,r){if(r){const i=r[getType(t)]||r;if(i===t||includes(i,t)||"all"===i)return!0;for(let e=0;e<i.length;e+=1)if(isEqual(i[e],t))return!0;printError(`'${t}' doesn't match any of the valid values for '${e}' (${"array"===getType(r)&&r.length>1?`${r.slice(0,-1).join(", ")} or ${r.slice(-1)}`:`${r}`}).`)}return!1}function validateValue(e,t,r){let i,n,a,o;const s=r[e],u=hasKey(t,e)?t[e]:"value_not_defined";let l=s;return s&&(i=s.type,n=s.valid,a=s.range,o=s.regex,l=hasKey(s,"default")?s.default:s),isDeclared(u)?l:isMatch(e,u,o)?u:isValid(e,u,n,i)?u:(isType(e,u,i),inRange(e,u,a),u)}class index{constructor(e){this.defaults=e}validate(e,t=this.defaults){const r={};for(const i in t)if(hasKey(t,i)){let n,a,o,s,u=t[i];if("object"!==getType(u)||hasKey(u,"default")&&"object"!==getType(u.default))r[i]=validateValue(i,e,t);else{r[i]={},u.default&&(n=u.type,a=u.valid,o=u.range,s=u.regex,u=u.default);for(const t in u)if(hasKey(u,t)){"object"===getType(u[t])&&(u[t].type=u[t].type||n,u[t].valid=u[t].valid||a,u[t].range=u[t].range||o,u[t].regex=u[t].regex||s);const l=e[i]||{};r[i][t]=validateValue(t,l,u)}}}return r}}module.exports=index;
