/*!
 * options-config v3.1.1
 * by Nil Vila
 */
import isNumber from"lodash.isnumber";import customError from"custom-error";import isEqual from"lodash.isequal";import includes from"lodash.includes";function getType(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function hasKey(e,t){return Object.prototype.hasOwnProperty.call(e,t)}function printError(e){throw customError("options-config")(e)}function inRange(e,t,r){if(r){const i=r.min,n=r.max,o=r.step;(!isNumber(i)&&void 0!==i||!isNumber(n)&&void 0!==n||!isNumber(o)&&void 0!==o)&&printError(`Range is not properly configured for '${e}'.`),(i>t||n<t||o&&!Number.isInteger(((i||0)-t)/o))&&printError(`${t} doesn't fit the range specified for '${e}'.`)}return!1}function isDeclared(e){return"value_not_defined"===e}function isMatch(e,t,r){if(r){if("string"===getType(t)&&t.match(r)&&t.match(r)[0]===t)return!0;printError(`'${t}' doesn't match the Regex expression ${r} for '${e}'.`)}return!1}function isType(e,t,r){const i=getType(t);if(r&&!r.includes(i)){printError(`'${t}', ${i}, is not a valid data type for '${e}' (${"array"===getType(r)&&r.length>1?`${r.slice(0,-1).join(", ")} or ${r.slice(-1)}`:`${r}`}).`)}return!1}function isValid(e,t,r){if(r){const i=r[getType(t)]||r;if(i===t||includes(i,t)||"all"===i)return!0;for(let e=0;e<i.length;e+=1)if(isEqual(i[e],t))return!0;printError(`'${t}' doesn't match any of the valid values for '${e}' (${"array"===getType(r)&&r.length>1?`${r.slice(0,-1).join(", ")} or ${r.slice(-1)}`:`${r}`}).`)}return!1}function validateValue(e,t,r){let i,n,o,a;const s=r[e],l=hasKey(t,e)?t[e]:"value_not_defined";let u=s;return s&&(i=s.type,n=s.valid,o=s.range,a=s.regex,u=hasKey(s,"default")?s.default:s),isDeclared(l)?u:isMatch(e,l,a)?l:isValid(e,l,n,i)?l:(isType(e,l,i),inRange(e,l,o),l)}class index{constructor(e){this.defaults=e}validate(e,t=this.defaults){const r={};for(const i in t)if(hasKey(t,i)){let n,o,a,s,l=t[i];if("object"!==getType(l)||hasKey(l,"default")&&"object"!==getType(l.default))r[i]=validateValue(i,e,t);else{r[i]={},l.default&&(n=l.type,o=l.valid,a=l.range,s=l.regex,l=l.default);for(const t in l)if(hasKey(l,t)){"object"===getType(l[t])&&(l[t].type=l[t].type||n,l[t].valid=l[t].valid||o,l[t].range=l[t].range||a,l[t].regex=l[t].regex||s);const u=e[i]||{};r[i][t]=validateValue(t,u,l)}}}return r}}export default index;
