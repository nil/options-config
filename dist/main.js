/*!
 * options-config v3.0.0
 * by Nil Vila
 */
import isNumber from"lodash.isnumber";import isEqual from"lodash.isequal";import includes from"lodash.includes";function getType(e){return{}.toString.call(e).match(/\s([a-zA-Z]+)/)[1].toLowerCase()}function hasKey(e,t){return Object.prototype.hasOwnProperty.call(e,t)}class PrintError{constructor(e){this.name="options-config",this.message=e,this.stack=(new Error).stack}}function inRange(e,t,r){if(r){const n=r.min,i=r.max,o=r.step;if(!isNumber(n)&&void 0!==n||!isNumber(i)&&void 0!==i||!isNumber(o)&&void 0!==o)throw new PrintError(`Range is not properly configured for '${e}'.`);if(n>t||i<t||o&&!Number.isInteger(((n||0)-t)/o))throw new PrintError(`${t} doesn't fit the range specified for '${e}'.`)}return!1}function isDeclared(e){return"value_not_defined"===e}function isMatch(e,t,r){if(r){if("string"===getType(t)&&t.match(r)&&t.match(r)[0]===t)return!0;throw new PrintError(`'${t}' doesn't match the Regex expression ${r} for '${e}'.`)}return!1}function isType(e,t,r){const n=getType(t);if(r&&!r.includes(n)){const i="array"===getType(r)&&r.length>1?`${r.slice(0,-1).join(", ")} or ${r.slice(-1)}`:`${r}`;throw new PrintError(`'${t}', ${n}, is not a valid data type for '${e}' (${i}).`)}return!1}function isValid(e,t,r){if(r){const n=r[getType(t)]||r;if(n===t||includes(n,t)||"all"===n)return!0;for(let e=0;e<n.length;e+=1)if(isEqual(n[e],t))return!0;const i="array"===getType(r)&&r.length>1?`${r.slice(0,-1).join(", ")} or ${r.slice(-1)}`:`${r}`;throw new PrintError(`'${t}' doesn't match any of the valid values for '${e}' (${i}).`)}return!1}function validateValue(e,t,r){let n,i,o,a;const s=r[e],l=hasKey(t,e)?t[e]:"value_not_defined";let c=s;return s&&(n=s.type,i=s.valid,o=s.range,a=s.regex,c=hasKey(s,"default")?s.default:s),isDeclared(l)?c:isMatch(e,l,a)?l:isValid(e,l,i,n)?l:(isType(e,l,n),inRange(e,l,o),l)}PrintError.prototype=new Error;class index{constructor(e){this.defaults=e}validate(e,t=this.defaults){const r={};for(const n in t)if(hasKey(t,n)){let i,o,a,s,l=t[n];if("object"!==getType(l)||hasKey(l,"default")&&"object"!==getType(l.default))r[n]=validateValue(n,e,t);else{r[n]={},l.default&&(i=l.type,o=l.valid,a=l.range,s=l.regex,l=l.default);for(const t in l)if(hasKey(l,t)){"object"===getType(l[t])&&(l[t].type=l[t].type||i,l[t].valid=l[t].valid||o,l[t].range=l[t].range||a,l[t].regex=l[t].regex||s);const c=e[n]||{};r[n][t]=validateValue(t,c,l)}}}return r}}export default index;
